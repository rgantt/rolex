h2. Rolex is a simple timing and profiling utility for PHP

Rolex is designed to time and document the performance of closures, since this is the easiest way to look at the execution time of an entire scope. It's "prettier" than just tossing in @start()@ and @stop()@ calls like most PHP profilers seem to do (although you can do that too, if you want).

The utility consists of a handful of utility classes that are easily accessible through a facade of static class methods.

h2. Example usage

Say you want to compare the execution time of PHP's variable access versus instance variable access. In that case, you would run two profiles (one for the former and one for the latter).

The first might look like:

pre. require_once "rolex/rolex.php";
$obj = new stdClass;
$obj->foo = "bar";
$dev_null = null;
echo rolex\r::run( "instance variable access", function() use( $obj, $dev_null ) {
    $dev_null = $obj->foo; // to test how long it takes to make the assignment
}, 1000);

The second:

pre. require_once "rolex/rolex.php";
$foo = "bar";
$dev_null = null;
echo rolex\r::run( "scope variable access", function() use( $foo, $dev_null ) {
    $dev_null = $foo;
}, 1000);

Profiling methods (or starting and stopping the profiler on your own) always creates a @result_set@ object which is populated with the message you provided (if any) and the duration. By default, using such a return value as a string simply displays the message, along with the average duratiofor the number of iterations you ran.

Of course, you can also do whatever you want with the @result_set@. It's just a linked list.

The profiling code and overhead is minimal. You call it simply, and it does what you expect: it displays the difference in float microtime between the moment the closure is called and the moment the closure is finished executing.

The default output of a call to @r::run@ is the message you provide the profiler with the execution time appended to it. For the first example, you might see @instance variable access 1.200102939933@ as the result.

h3. Manual starts and stops

If you prefer not to use a closure, you can also simply time other blocks of code as you see fit. All that's required is that you provide a unique key to the @r::start()@ method so that rolex can keep track of which timers are currently going.

For example, measure this loop:

pre. require_once "rolex/lib/rolex.php";
r::start( "a unique key", "measure my function!" );
for( $i = 0; $i < 10000000; $i++ ) {
	do_something_measurable();
}
echo r::stop("a unique key");

We provide @r::start@ with a unique key and a message that we'll want to be displayed later. To stop this timer, call @r::stop()@ and provide it with the unique key for the timer you'd like to end. @r::stop()@ returns a result object, which contains both a message and a duration.